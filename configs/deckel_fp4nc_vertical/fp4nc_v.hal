# 3 axis toolroom mill with Mesa 7i92/7i77/7i74/7i70/7i71
# VERTICAL SPINDLE
# kinematics
loadrt [KINS]KINEMATICS

# motion controller, get name and thread periods from ini file
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS

# standard components

loadrt and2 count=18
loadrt conv_bit_float count=2
loadrt conv_float_s32 count=7
loadrt conv_s32_float count=2
loadrt limit1 count=2
loadrt logic count=5 personality=0x103,0x103,0x103,0x104,0x102,   #and with 3 inputs 3 times; with 4 inputs once; with 2 inputs once.
loadrt lowpass count=4 
loadrt mult2 count=1
loadrt mux2 count=3
loadrt mux8 count=1
loadrt near count=1
loadrt not count=11
loadrt or2 count=7
loadrt pid names=pid.x,pid.y,pid.z
loadrt scale count=12
loadrt select8 count=1
loadrt sum2 count=1
loadrt timedelay count=4
loadrt toggle count=7
loadrt toggle2nist count=2


# hostmot2 driver
# if you have any firmware trouble, enable the debug flags here and see what's going on in the syslog
# loadrt hostmot2 debug_idrom=1 debug_module_descriptors=1 debug_pin_descriptors=1 debug_modules=1
loadrt hostmot2

# load low-level driver
loadrt  [HOSTMOT2](DRIVER) board_ip=[HOSTMOT2](BOARD_IP) config=[HOSTMOT2](CONFIG)
setp    hm2_[HOSTMOT2](BOARD).0.watchdog.timeout_ns 5000000


# threads
addf hm2_[HOSTMOT2](BOARD).0.read           servo-thread

addf motion-command-handler                 servo-thread
addf motion-controller                      servo-thread
addf mult2.0                                servo-thread
addf pid.x.do-pid-calcs                     servo-thread
addf pid.y.do-pid-calcs                     servo-thread
addf pid.z.do-pid-calcs                     servo-thread
addf scale.0                                servo-thread
addf scale.1                                servo-thread
addf scale.2                                servo-thread
addf scale.3                                servo-thread
addf scale.4                                servo-thread
addf scale.5                                servo-thread
addf scale.6                                servo-thread
addf scale.7                                servo-thread
addf scale.8                                servo-thread
addf scale.9                                servo-thread
addf scale.10                               servo-thread
addf scale.11                               servo-thread
addf timedelay.0                            servo-thread
addf timedelay.1                            servo-thread
addf timedelay.2                            servo-thread
addf timedelay.3                            servo-thread
addf and2.0	                                servo-thread
addf and2.1                                 servo-thread
addf and2.2                                 servo-thread
addf and2.3                                 servo-thread
addf and2.4                                 servo-thread
addf and2.5                                 servo-thread
addf and2.6                                 servo-thread
addf and2.7                                 servo-thread
addf and2.8                                 servo-thread
addf and2.9                                 servo-thread
addf and2.10                                servo-thread
addf and2.11                                servo-thread
addf and2.12                                servo-thread
addf and2.13                                servo-thread
addf and2.14                                servo-thread
addf and2.15                                servo-thread
addf and2.16                                servo-thread
addf and2.17                                servo-thread
addf conv-bit-float.0                       servo-thread
addf conv-bit-float.1                       servo-thread
addf conv-float-s32.0                       servo-thread
addf conv-float-s32.1                       servo-thread
addf conv-float-s32.2                       servo-thread
addf conv-float-s32.3                       servo-thread
addf conv-float-s32.4                       servo-thread
addf conv-float-s32.5                       servo-thread
addf conv-float-s32.6                       servo-thread
addf conv-s32-float.0                       servo-thread
addf conv-s32-float.1                       servo-thread
addf limit1.0                               servo-thread
addf limit1.1                               servo-thread
addf logic.0                                servo-thread
addf logic.1                                servo-thread
addf logic.2                                servo-thread
addf logic.3                                servo-thread
addf logic.4                                servo-thread
addf lowpass.0                              servo-thread
addf lowpass.1                              servo-thread
addf lowpass.2                              servo-thread
addf lowpass.3                              servo-thread
addf mux2.0                                 servo-thread
addf mux2.1                                 servo-thread
addf mux2.2                                 servo-thread
addf mux8.0                                 servo-thread
addf near.0                                 servo-thread
addf not.0                                  servo-thread
addf not.1                                  servo-thread
addf not.2                                  servo-thread
addf not.3                                  servo-thread
addf not.4                                  servo-thread
addf not.5                                  servo-thread
addf not.6                                  servo-thread
addf not.7                                  servo-thread
addf not.8                                  servo-thread
addf not.9                                  servo-thread
addf not.10                                 servo-thread
addf or2.0                                  servo-thread
addf or2.1                                  servo-thread
addf or2.2                                  servo-thread
addf or2.3                                  servo-thread
addf or2.4                                  servo-thread
addf or2.5                                  servo-thread
addf or2.6                                  servo-thread
addf select8.0                              servo-thread
addf sum2.0                                 servo-thread
addf toggle.0                               servo-thread
addf toggle.1                               servo-thread
addf toggle.2                               servo-thread
addf toggle.3                               servo-thread
addf toggle.4                               servo-thread
addf toggle.5                               servo-thread
addf toggle.6                               servo-thread
addf toggle2nist.0                          servo-thread
addf toggle2nist.1                          servo-thread

addf hm2_[HOSTMOT2](BOARD).0.write          servo-thread

# 7i70 Digital Inputs
net   gearbox_microswitch_S36         <=    hm2_7i92.0.7i70.1.0.input-00
net   gearbox_microswitch_S37         <=    hm2_7i92.0.7i70.1.0.input-01
net   gearbox_microswitch_S38         <=    hm2_7i92.0.7i70.1.0.input-02
net   gearbox_microswitch_S39         <=    hm2_7i92.0.7i70.1.0.input-03
net   gearbox_microswitch_S40         <=    hm2_7i92.0.7i70.1.0.input-04
net   gearbox_microswitch_S41         <=    hm2_7i92.0.7i70.1.0.input-05
net   gearbox_microswitch_S42         <=    hm2_7i92.0.7i70.1.0.input-06
net   gearbox_microswitch_S43         <=    hm2_7i92.0.7i70.1.0.input-07
net   gearbox_microswitch_S44         <=    hm2_7i92.0.7i70.1.0.input-08
net   hydraulic_pressure_switch_S33   <=    hm2_7i92.0.7i70.1.0.input-09
net   lube_pressure_switch_S34        <=    hm2_7i92.0.7i70.1.0.input-10

net   mcp_tool_change_S22             <=    hm2_7i92.0.7i70.1.0.input-14
net   mcp_lube_cycle_S23              <=    hm2_7i92.0.7i70.1.0.input-15
net   pendant_release_tool_S06        <=    hm2_7i92.0.7i70.1.0.input-16
net   toolsetter_switch_S66           <=    hm2_7i92.0.7i70.1.0.input-17
net   toolsetter_overtravel_S67       <=    hm2_7i92.0.7i70.1.0.input-18

net   access_gate_state               <=    hm2_7i92.0.7i70.1.0.input-24
net   e-stop_button_chain_state       <=    hm2_7i92.0.7i70.1.0.input-25
net   axes_e-stop_chain_state         <=    hm2_7i92.0.7i70.1.0.input-26
net   axes_safety_relay_state         <=    hm2_7i92.0.7i70.1.0.input-27
net   spindle_safety_relay_state      <=    hm2_7i92.0.7i70.1.0.input-28
net   access_gate_override_state      <=    hm2_7i92.0.7i70.1.0.input-29
net   x_minus_range_end               <=    hm2_7i92.0.7i70.1.0.input-30-not
net   x_minus_reduce                  <=    hm2_7i92.0.7i70.1.0.input-31-not   
net   x_plus_reduce                   <=    hm2_7i92.0.7i70.1.0.input-32-not
net   x_plus_range_end                <=    hm2_7i92.0.7i70.1.0.input-33-not
net   y_minus_range_end               <=    hm2_7i92.0.7i70.1.0.input-34-not
net   y_minus_reduce                  <=    hm2_7i92.0.7i70.1.0.input-35-not   
net   y_plus_reduce                   <=    hm2_7i92.0.7i70.1.0.input-36-not
net   y_plus_range_end                <=    hm2_7i92.0.7i70.1.0.input-37-not
net   z_minus_range_end               <=    hm2_7i92.0.7i70.1.0.input-38-not
net   z_minus_reduce                  <=    hm2_7i92.0.7i70.1.0.input-39-not   
net   z_plus_reduce                   <=    hm2_7i92.0.7i70.1.0.input-40-not
net   z_plus_range_end                <=    hm2_7i92.0.7i70.1.0.input-41-not
net   x_axis_servo_drive_ok           <=    hm2_7i92.0.7i70.1.0.input-42
net   x_axis_servo_drive_zero_speed   <=    hm2_7i92.0.7i70.1.0.input-43
net   y_axis_servo_drive_ok           <=    hm2_7i92.0.7i70.1.0.input-44
net   y_axis_servo_drive_fault        <=    hm2_7i92.0.7i70.1.0.input-44-not
net   y_axis_servo_drive_zero_speed   <=    hm2_7i92.0.7i70.1.0.input-45
net   z_axis_servo_drive_ok           <=    hm2_7i92.0.7i70.1.0.input-46
net   z_axis_servo_drive_zero_speed   <=    hm2_7i92.0.7i70.1.0.input-47

# 7i71 Digital Outputs
net   gearbox_motor_M5_relay_K13      =>    hm2_7i92.0.7i71.1.1.output-00
net   gearbox_motor_M6_relay_K14      =>    hm2_7i92.0.7i71.1.1.output-01
net   gearbox_motor_M7_relay_K15      =>    hm2_7i92.0.7i71.1.1.output-02
net   gearbox_motors_rev_relay_K16    =>    hm2_7i92.0.7i71.1.1.output-03
net   spindle_lube_relay_K19          =>    hm2_7i92.0.7i71.1.1.output-04
#net   hydraulic_pump_relay_K20        =>    hm2_7i92.0.7i71.1.1.output-05
#net   release_tool_relay_K21          =>    hm2_7i92.0.7i71.1.1.output-06
net   central_lube_pump_relay_K22     =>    hm2_7i92.0.7i71.1.1.output-07
net   mist_coolant_relay_K28          =>    hm2_7i92.0.7i71.1.1.output-08
net   flood_coolant_relay_K29         =>    hm2_7i92.0.7i71.1.1.output-09

# 7i77 Analog Inputs
net   mcp_spindle_speed_analog        <=    hm2_7i92.0.7i77.0.0.analogin0
net   mcp_spindle_override_analog     <=    hm2_7i92.0.7i77.0.0.analogin1
net   mcp_feed_override_analog        <=    hm2_7i92.0.7i77.0.0.analogin2
net   motor_vfd2_actual_speed_volts   <=    hm2_7i92.0.7i77.0.0.analogin3

# 7i77 Digital Inputs
net   mcp_home_S10                    <=    hm2_7i92.0.7i77.0.0.input-04
net   mcp_jog_z_minus_S11             <=    hm2_7i92.0.7i77.0.0.input-05
net   mcp_jog_y_plus_S12              <=    hm2_7i92.0.7i77.0.0.input-06
net   mcp_jog_x_plus_S13              <=    hm2_7i92.0.7i77.0.0.input-07
net   mcp_jog_x_minus_S14             <=    hm2_7i92.0.7i77.0.0.input-08
net   mcp_jog_y_minus_S15             <=    hm2_7i92.0.7i77.0.0.input-09
net   mcp_jog_z_plus_S16              <=    hm2_7i92.0.7i77.0.0.input-10
net   mcp_axes_retract_S17            <=    hm2_7i92.0.7i77.0.0.input-11
net   mcp_rapid_jog_S18               <=    hm2_7i92.0.7i77.0.0.input-12

net   mpg_enc_A                       =>    hm2_7i92.0.7i77.0.0.input-16
net   mpg_enc_B                       =>    hm2_7i92.0.7i77.0.0.input-17

net   mpg_x_S01                       <=    hm2_7i92.0.7i77.0.0.input-20
net   mpg_y_S02                       <=    hm2_7i92.0.7i77.0.0.input-21
net   mpg_z_S03                       <=    hm2_7i92.0.7i77.0.0.input-22
net   mpg_on_S04                      <=    hm2_7i92.0.7i77.0.0.input-23
net   mpg_jog_rate_S05                <=    hm2_7i92.0.7i77.0.0.input-24
net   mcp_spindle_cw_S19              <=    hm2_7i92.0.7i77.0.0.input-25
net   mcp_spindle_ccw_S19             <=    hm2_7i92.0.7i77.0.0.input-26
net   mcp_cycle_start_S24             <=    hm2_7i92.0.7i77.0.0.input-27
net   mcp_cycle_stop_S25              <=    hm2_7i92.0.7i77.0.0.input-28
net   mcp_spindle_run_S20             <=    hm2_7i92.0.7i77.0.0.input-29

net   enable_servo_drives             <=    hm2_7i92.0.7i77.0.0.input-31

# 7i77 Digital Outputs
#net   x_axis_brake_release_relay_K10  =>    hm2_7i92.0.7i77.0.0.output-00
#net   y_axis_brake_release_relay_K11  =>    hm2_7i92.0.7i77.0.0.output-01
#net   z_axis_brake_release_relay_K12  =>    hm2_7i92.0.7i77.0.0.output-02
net   spindle_jog_vfd2_DI2            =>    hm2_7i92.0.7i77.0.0.output-03
#net   run_servo_drives_relay_K07      =>    hm2_7i92.0.7i77.0.0.output-04
net   axes_retract_relay_K08          =>    hm2_7i92.0.7i77.0.0.output-05
net   access_gate_override_relay_K05  =>    hm2_7i92.0.7i77.0.0.output-06
#net   enable_servo_drives_relay_K06   =>    hm2_7i92.0.7i77.0.0.output-07

#net   mpg_x_lamp_H01                  =>    hm2_7i92.0.7i77.0.0.output-08
#net   mpg_y_lamp_H02                  =>    hm2_7i92.0.7i77.0.0.output-09
#net   mpg_z_lamp_H03                  =>    hm2_7i92.0.7i77.0.0.output-10
#net   mpg_on_lamp_H04                 =>    hm2_7i92.0.7i77.0.0.output-11
#net   mpg_jog_rate_lamp_H05           =>    hm2_7i92.0.7i77.0.0.output-12

net   spindle_run_vfd2_DI1            =>    hm2_7i92.0.7i77.0.0.output-15

# 7i77 Analog Outputs
#net     x-output                      =>    hm2_7i92.0.7i77.0.1.analogout0
#net     y-output                      =>    hm2_7i92.0.7i77.0.1.analogout1
#net     z-output                      =>    hm2_7i92.0.7i77.0.1.analogout2
#net     spindle_vfd2_analog_voltage   =>    hm2_7i92.0.7i77.0.1.analogout5

#Axis E-Stop over-ride
#E-stop the machine from the Machine Control Panel
#Set the axes_retract_relay_K08 True
#Reset the Machine Control Panel E-Stop and Activate the machine
#For the Z axis; always have the Z power ON otherwise the table will drop.

#Machine Activated - not estopped and activated by physical button
net   axes_safety_relay_state         =>    and2.0.in0
net   spindle_safety_relay_state      =>    and2.0.in1
net   estop-reset                     <=    and2.0.out

#Machine E-stopped - either e-stop buttons or axes estops tripped, or not re-set
net   estop-reset                     =>    not.0.in
net   estop-in                        <=    not.0.out

#Send physical E-stop state to UI
net   estop-reset                      =>    iocontrol.0.emc-enable-in

#Run Servo drives (T5) i.e turn main power contactors ON via servo drive relays
net   estop-reset              		   =>     hm2_7i92.0.7i77.0.0.output-04

#Enable Drives (T20): enable servo controllers with time delay after T5
setp  timedelay.0.on-delay                2.0
setp  timedelay.0.off-delay               0.0
net   estop-reset         			          =>   timedelay.0.in
net	  enable_analog_outputs               <=   timedelay.0.out
net   enable_analog_outputs               =>   hm2_7i92.0.7i77.0.1.analogena
net   enable_servo_drives                 <=   hm2_7i92.0.7i77.0.0.input-31
net   enable_servo_drives                 =>   hm2_7i92.0.7i77.0.0.output-07

#Turn machine ON in GUI (seems to need a time delay; doesn't work with estop-reset)
net   enable_servo_drives                 =>   halui.machine.on

#Release axes brakes
#Only if:
#  not estop
#  analogue outputs enabled
#  servo drives enabled
#  servo drive health OK on an axis by axis basis
#  joint following error within limits on a joint by joint basis
#  WARNING: servo drive reports health OK even if main servo power is isolated
#  protection against loss of mains power to servo drive is through following error
#E-Stop and Activate to recover
setp  timedelay.1.on-delay                    0.3
setp  timedelay.1.off-delay                   0.0
net   enable_servo_drives                 =>  timedelay.1.in
net   release_axes_brakes                 <=  timedelay.1.out

# joint following error detection
net   joint_0_f-error                     <=  joint.0.f-errored  =>  not.2.in
net   joint_0_f-error_not                 <=  not.2.out
net   joint_1_f-error                     <=  joint.1.f-errored  =>  not.3.in
net   joint_1_f-error_not                 <=  not.3.out
net   joint_2_f-error                     <=  joint.2.f-errored  =>  not.4.in
net   joint_2_f-error_not                 <=  not.4.out

#release axes brakes
net   release_axes_brakes                 =>  logic.0.in-00
net   x_axis_servo_drive_ok               =>  logic.0.in-01
net   joint_0_f-error_not                 =>  logic.0.in-02
#setp    logic.0.in-02 true
net   x_axis_brake_release                <=  logic.0.and

net   release_axes_brakes                 =>  logic.1.in-00
net   y_axis_servo_drive_ok               =>  logic.1.in-01
net   joint_1_f-error_not                 =>  logic.1.in-02
#setp    logic.1.in-02 true
net   y_axis_brake_release                <=  logic.1.and

net   release_axes_brakes                 =>  logic.2.in-00
net   z_axis_servo_drive_ok               =>  logic.2.in-01
net   joint_2_f-error_not                 =>  logic.2.in-02
#setp    logic.2.in-02 true
net   z_axis_brake_release                <=  logic.2.and

net   x_axis_brake_release                =>  hm2_7i92.0.7i77.0.0.output-00      #X axis
net   y_axis_brake_release                =>  hm2_7i92.0.7i77.0.0.output-01      #Y axis
net   z_axis_brake_release                =>  hm2_7i92.0.7i77.0.0.output-02      #Z axis

#Spindle enable
setp  timedelay.1.on-delay                    2.0
setp  timedelay.1.off-delay                   0.0
net   enable_analog_outputs                   =>  timedelay.2.in
net   spindle_enable                          <=  timedelay.2.out
net   spindle_enable                          =>  hm2_7i92.0.7i77.0.1.spinena

#Spindle run and inhibit - run needs a time delay from enable to avoid VFD Nst error
setp  timedelay.3.on-delay                    1.0
setp  timedelay.3.off-delay                   0.0
net   spindle_enable                          =>    timedelay.3.in
net   spindle_run_vfd2_DI1_primed             <=    timedelay.3.out
net   spindle_inhibit                         <=    spindle.0.inhibit
net   spindle_inhibit                         =>    not.1.in
net   spindle_inhibit_not                     <=    not.1.out
net   spindle_inhibit_not                     =>    and2.7.in0
net   spindle_run_vfd2_DI1_primed             =>    and2.7.in1
net   spindle_run_vfd2_DI1                    <=    and2.7.out

#turn the spindle ON/OFF from the machine control panel momentary switch S20
#the switch is prevented from toggling during gearshift or when safe_tool_change_request is True
#the switch state is forced OFF when the toggle is blocked.
#blocking condition
net   gearshift_is_blocking                   =>    or2.6.in0
net   safe_tool_change_request                =>    or2.6.in1
net   mcp_S20_blocked                         <=    or2.6.out 

net   mcp_S20_blocked                         =>    not.10.in
net   mcp_S20_enabled                         <=    not.10.out                       

#Allow S20 toggling only when enabled
net   mcp_S20_enabled                         =>    and2.16.in0
net   mcp_spindle_run_S20                     =>    and2.16.in1
net   mcp_spindle_run_S20_filtered            <=    and2.16.out

net   mcp_spindle_run_S20_filtered            =>    toggle.0.in
net   mcp_spindle_run_toggle_state            <=    toggle.0.out

#Force spindle OFF if blocked by tying mcp_spindle_run_S20_state to mcp_s20_enabled
net   mcp_spindle_run_toggle_state            =>    and2.17.in0
net   mcp_S20_enabled                         =>    and2.17.in1
net   mcp_spindle_run_S20_state               <=    and2.17.out

#Explicit manual spindle_stop to connect to halui
net   mcp_spindle_run_S20_state               =>    not.5.in
net   manual_spindle_stop                     <=    not.5.out

#spindle direction
net   mcp_spindle_cw_S19                      =>    and2.9.in0
net   mcp_spindle_run_S20_state               =>    and2.9.in1
net   manual_spindle_run_forward              <=    and2.9.out 

net   mcp_spindle_ccw_S19                     =>    and2.10.in0
net   mcp_spindle_run_S20_state               =>    and2.10.in1
net   manual_spindle_run_reverse              <=    and2.10.out

#halui
net   manual_spindle_run_forward              =>    halui.spindle.0.forward
net   manual_spindle_run_reverse              =>    halui.spindle.0.reverse                  
net   manual_spindle_stop                     =>    halui.spindle.0.stop     

#Spindle speed override
setp halui.spindle.0.override.direct-value    true
setp halui.spindle.0.override.count-enable    true
#20.0V maps to 50%, 2.3V maps to 140%
#(20-2.3)=17.7V; (50-140)=-90; gain=-90/17.7; offset = (50 - gain * 20) = 151.69
#bound the maximum spindle speed for now to 100% by setting the analog min limit to 9.6V
setp scale.3.gain                               -5.084
setp scale.3.offset                             151.69
setp halui.spindle.0.override.scale             0.01
setp limit1.0.min                               9.6
setp limit1.0.max                               20.0
net  mcp_spindle_override_analog                =>    limit1.0.in
net  mcp_spindle_override_analog_bounded        <=    limit1.0.out
net  mcp_spindle_override_analog_bounded        =>    scale.3.in
net  spindle_override_scaled                    <=    scale.3.out            =>  conv-float-s32.0.in
net  spindle_override_percent                   <=    conv-float-s32.0.out
net  spindle_override_percent                   =>    halui.spindle.0.override.counts

#Manual spindle speed setpoint
loadusr -W manual_spindle_setpoint
net   mcp_spindle_speed_analog                  =>    manual_spindle_setpoint.mcp_analog
net   mcp_spindle_cw_S19                        =>    manual_spindle_setpoint.mcp_spindle_cw_S19
net   spindle_setpoint_rps_manual               <=    manual_spindle_setpoint.setpoint_rps

#determine actual spindle speed feedback
#motor actual speed comes from the VFD AQ1 output as a 0-10V output:
# 0V = -60 Hz, 4.769V plus or minus 0.071V = 0 speed, 10V = 60 Hz
#gear ratio adjusts motor speed to give spindle speed
#output is in Hz (rps)
setp  scale.2.gain                            12.0
setp  scale.2.offset                          -57.028                      
setp  lowpass.3.gain                          0.01
net   motor_vfd2_actual_speed_volts           =>      lowpass.3.in
net   actual_speed_volts_filtered             <=      lowpass.3.out
net   actual_speed_volts_filtered             =>      scale.2.in
net   motor_vfd2_actual_speed_rps             <=      scale.2.out
net   gear_ratio                              =>      scale.4.gain
net   motor_vfd2_actual_speed_rps             =>      scale.4.in
net   spindle_actual_speed_rps                <=      scale.4.out         => spindle.0.speed-in

#check if spindle is at-speed
setp  scale.7.gain                            0.01
net   spindle_override_percent                =>      conv-s32-float.1.in
net   spindle_override_percent_float          <=      conv-s32-float.1.out 
net   spindle_override_percent_float          =>      scale.7.in
net   spindle_override_fraction               <=      scale.7.out
net   spindle_override_fraction               =>      scale.8.gain
net   spindle_cmd_rps                         =>      scale.8.in
net   spindle_cmd_rps_overridden              <=      scale.8.out
setp  near.0.scale                            1.1     #relative - but doesn't work for 0 speed
setp  near.0.difference                       0.8     #[rps] absolute (48rpm) - to handle the zero speed case
net   spindle_actual_speed_rps                =>      near.0.in1
net   spindle_cmd_rps_overridden              =>      near.0.in2
net   spindle_at_speed                        <=      near.0.out
net   gearshift_is_blocking_not               =>      and2.11.in0
net   spindle_at_speed                        =>      and2.11.in1
net   motion_enable                           <=      and2.11.out         => spindle.0.at-speed
net   motion_enable                           =>      not.6.in
net   feed_inhibit                            <=      not.6.out
net   feed_inhibit                            =>      motion.feed-inhibit                           

#spindle states
net   spindle_cw_run                          <=    spindle.0.forward
net   spindle_ccw_run                         <=    spindle.0.reverse
net   spindle_on                              <=    spindle.0.on
net   spindle_on                              =>    not.8.in
net   spindle_off                             <=    not.8.out
net   spindle_setpoint_rps_auto_mdi           <=    spindle.0.speed-cmd-rps
net   spindle_speed_out_rps                   <=    spindle.0.speed-out-rps

#mode dependant spindle speed command
net   mode_is_manual                          <=    halui.mode.is-manual
net   mode_is_manual                          =>    mux2.1.sel
net   spindle_setpoint_rps_auto_mdi           =>    mux2.1.in0
net   spindle_setpoint_rps_manual             =>    mux2.1.in1
net   spindle_cmd_rps                         <=    mux2.1.out

#VFD analog voltage - scaled by spindle_override_fraction
net   spindle_override_fraction               =>   scale.6.gain                   
net   spindle_vfd2_analog_nom                 =>   scale.6.in
net   spindle_vfd2_analog_voltage             <=   scale.6.out
net   spindle_vfd2_analog_voltage             =>   hm2_7i92.0.7i77.0.1.analogout5

#Tool change
#Make the tool change_request switch effective only when spindle is OFF
net   mcp_tool_change_S22                 =>  and2.15.in0
net   spindle_off                         =>  and2.15.in1
net   safe_tool_change_request            <=  and2.15.out
net   safe_tool_change_request            =>  not.9.in
net   safe_tool_change_request_not        <=  not.9.out        
#Check if the hydraulic pump has made pressure
net   hydraulic_pressure_switch_S33       =>  not.7.in
net   hyd_presssure_not                   <=  not.7.out
#Should pump run? only when these conditions are true
net   safe_tool_change_request            =>  logic.3.in-00
net   pendant_release_tool_S06            =>  logic.3.in-01
net   hyd_presssure_not                   =>  logic.3.in-02
net   estop-reset                         =>  logic.3.in-03
net   hydraulic_pump_relay_K20            <=  logic.3.and
#run pump
net   hydraulic_pump_relay_K20            =>  hm2_7i92.0.7i71.1.1.output-05  

#Should tool be released? only when these conditions are true
#pump running is hardware enabled by K21 as an additional protection
net   safe_tool_change_request            =>  logic.4.in-00
net   pendant_release_tool_S06            =>  logic.4.in-01
net   release_tool_relay_K21              <=  logic.4.and
#do it
net   release_tool_relay_K21              =>  hm2_7i92.0.7i71.1.1.output-06

#spindle motor speed control and gearbox ratio selection
loadusr -W fp4_gearbox

net   gearbox_microswitch_S36                 =>    fp4_gearbox.gearbox_microswitch_S36
net   gearbox_microswitch_S37                 =>    fp4_gearbox.gearbox_microswitch_S37
net   gearbox_microswitch_S38                 =>    fp4_gearbox.gearbox_microswitch_S38

net   gearbox_microswitch_S39                 =>    fp4_gearbox.gearbox_microswitch_S39
net   gearbox_microswitch_S40                 =>    fp4_gearbox.gearbox_microswitch_S40
net   gearbox_microswitch_S41                 =>    fp4_gearbox.gearbox_microswitch_S41

net   gearbox_microswitch_S42                 =>    fp4_gearbox.gearbox_microswitch_S42
net   gearbox_microswitch_S43                 =>    fp4_gearbox.gearbox_microswitch_S43
net   gearbox_microswitch_S44                 =>    fp4_gearbox.gearbox_microswitch_S44

net   gearbox_hirange_state                   =>    fp4_gearbox.gearbox_hirange_state
sets  gearbox_hirange_state                         false

net   safe_tool_change_request                =>    fp4_gearbox.safe_tool_change_request

net   spindle_jog_motor_frequency             =>    fp4_gearbox.spindle_jog_motor_frequency
sets  spindle_jog_motor_frequency                   4.0  #Hz
net   spindle_jog_period                      =>    fp4_gearbox.spindle_jog_period
sets  spindle_jog_period                            5.0  #s
net   max_shift_time                          =>    fp4_gearbox.max_shift_time
sets  max_shift_time                                10.0  #s

net   spindle_run_vfd2_DI1                    =>    fp4_gearbox.spindle_run_vfd2_DI1
net   spindle_cw_run                          =>    fp4_gearbox.spindle_cw_run
net   spindle_ccw_run                         =>    fp4_gearbox.spindle_ccw_run
net   spindle_on                              =>    fp4_gearbox.spindle_on
net   spindle_cmd_rps                         =>    fp4_gearbox.spindle_cmd_rps
net   spindle_speed_out_rps                   =>    fp4_gearbox.spindle_speed_out_rps
net   spindle_actual_speed_rps                =>    fp4_gearbox.spindle_actual_speed_rps

net   gearbox_motor_M5_relay_K13              <=    fp4_gearbox.gearbox_motor_M5_relay_K13
net   gearbox_motor_M6_relay_K14              <=    fp4_gearbox.gearbox_motor_M6_relay_K14
net   gearbox_motor_M7_relay_K15              <=    fp4_gearbox.gearbox_motor_M7_relay_K15
net   gearbox_motors_rev_relay_K16            <=    fp4_gearbox.gearbox_motors_rev_relay_K16

net   gearshift_is_error                      <=    fp4_gearbox.gearshift_is_error
net   gearshift_error_code                    <=    fp4_gearbox.gearshift_error_code
net   gearshift_is_blocking                   <=    fp4_gearbox.gearshift_is_blocking
net   gearshift_is_blocking_not               <=    fp4_gearbox.gearshift_is_blocking_not
net   spindle_vfd2_analog_nom                 <=    fp4_gearbox.spindle_vfd2_analog_nom
net   gear_ratio                              <=    fp4_gearbox.gear_ratio
net   gearbox_output_speed                    <=    fp4_gearbox.gearbox_output_speed
net   state_machine_state                     <=    fp4_gearbox.state_machine_state
net   spindle_speed_override                  <=    fp4_gearbox.spindle_speed_override

#add conversions to rpm for UI tab gearbox
# Spindle speed conversion from rps to rpm
setp scale.9.gain                                   60.0
setp scale.10.gain                                  60.0
setp scale.11.gain                                  60.0

net spindle_cmd_rps                           => scale.9.in
net spindle_cmd_rpm                           <= scale.9.out
net spindle_cmd_rpm                           => conv-float-s32.4.in

net spindle_actual_speed_rps                  => scale.10.in
net spindle_actual_rpm                        <= scale.10.out
net spindle_actual_rpm                        => conv-float-s32.5.in

net gearbox_output_speed                      => conv-float-s32.6.in 

net spindle_cmd_rpm_int                       <= conv-float-s32.4.out 
net spindle_actual_rpm_int                    <= conv-float-s32.5.out
net gearbox_nominal_speed_int                 <= conv-float-s32.6.out


#Halui
#Cycle start and stop with 2 momentary switches
#net   mcp_cycle_start_S24             =>    toggle2nist.0.in
#net   mcp_cycle_stop_S25              =>    or2.3.in0
#net   estop-in                        =>    or2.3.in1
#net   cycle_stop                      <=    or2.3.out
#net   cycle_stop                      =>    toggle2nist.0.is-on
#net   cycle_start                     <=    toggle2nist.0.on
#net   cycle_start                     =>    halui.program.run
#net   cycle_stop                      =>    halui.program.stop

#Cycle Control: Run-Step / Hold-Resume behaviour from cycle start and cycle stop buttons
#Press START to start executing a program
#Press STOP while a program is running to pause the program
#Press START while a program is paused to single step the program
#Press STOP while the program is paused to return it to normal run mode
net   program_is_paused               <=    halui.program.is-paused
net   program_is_running              <=    halui.program.is-running
net   program_is_idle                 <=    halui.program.is-idle

net   mcp_cycle_stop_S25              =>    and2.1.in0
net   program_is_paused               =>    and2.1.in1
net   resume_signal                   <=    and2.1.out

net   mcp_cycle_stop_S25              =>    and2.2.in0
net   program_is_running              =>    and2.2.in1
net   pause_signal                    <=    and2.2.out

net   resume_signal                   =>    or2.3.in0
net   pause_signal                    =>    or2.3.in1
net   toggle_ok                       <=    or2.3.out
net   toggle_ok                       =>    toggle.6.in
net   toggle_signal                   <=    toggle.6.out
net   toggle_signal                   =>    toggle2nist.0.in
net   program_is_paused               =>    toggle2nist.0.is-on
net   toggle_on                       <=    toggle2nist.0.on
net   toggle_off                      <=    toggle2nist.0.off
net   toggle_on                       =>    halui.program.pause
net   toggle_off                      =>    halui.program.resume

net   mcp_cycle_start_S24             =>    and2.3.in0
net   program_is_idle                 =>    and2.3.in1
net   run_signal                      <=    and2.3.out
net   run_signal                      =>    halui.mode.auto
net   run_signal                      =>    halui.program.run

net   mcp_cycle_start_S24             =>    and2.4.in0
net   program_is_paused               =>    and2.4.in1
net   step_signal                     <=    and2.4.out
net   step_signal                     =>    halui.program.step

#MPG Handwheel - axis jogging in position mode
#encoder
#setp  hm2_7i92.0.7i77.0.0.enc0.counter-mode    1
#setp  hm2_7i92.0.7i77.0.0.enc0.filter          1
setp  hm2_7i92.0.7i77.0.0.enc0.scale           1
net   mpg_count                       <=    hm2_7i92.0.7i77.0.0.enc0.count
net   mpg_count                       =>    axis.x.jog-counts
net   mpg_count                       =>    axis.y.jog-counts
net   mpg_count                       =>    axis.z.jog-counts

#latch momentary inputs
net   mpg_on_S04                      =>    toggle.1.in
net   mpg_on_state                    <=    toggle.1.out
net   mpg_x_S01                       =>    toggle.2.in
net   mpg_x_state                     <=    toggle.2.out
net   mpg_y_S02                       =>    toggle.3.in
net   mpg_y_state                     <=    toggle.3.out
net   mpg_z_S03                       =>    toggle.4.in
net   mpg_z_state                     <=    toggle.4.out
net   mpg_jog_rate_S05                =>    toggle.5.in
net   mpg_jog_rate_state              <=    toggle.5.out

#pendant needs to be turned on for axes switches to take effect
net   mpg_on_state                    =>    and2.12.in0
net   mpg_x_state                     =>    and2.12.in1
net   mpg_x_on                        <=    and2.12.out

net   mpg_on_state                    =>    and2.13.in0
net   mpg_y_state                     =>    and2.13.in1
net   mpg_y_on                        <=    and2.13.out

net   mpg_on_state                    =>    and2.14.in0
net   mpg_z_state                     =>    and2.14.in1
net   mpg_z_on                        <=    and2.14.out

#set jog rate to one of two values; toggles on switch push
net   mpg_jog_rate_1                  =>    mux2.2.in0
sets  mpg_jog_rate_1                        0.005
net   mpg_jog_rate_2                  =>    mux2.2.in1
sets  mpg_jog_rate_2                        0.5
net   mpg_jog_rate_state              =>    mux2.2.sel
net   mpg_jog_rate                    <=    mux2.2.out
net   mpg_jog_rate                    =>    halui.joint.selected.increment
net   mpg_jog_rate                    =>    axis.x.jog-scale
net   mpg_jog_rate                    =>    axis.y.jog-scale
net   mpg_jog_rate                    =>    axis.z.jog-scale

#select active axis - only one active axis switch is required for a valid selection
setp  mux8.0.in0                            0
setp  mux8.0.in1                            1
setp  mux8.0.in2                            2
setp  mux8.0.in3                            3
setp  mux8.0.in4                            4
setp  mux8.0.in5                            5
setp  mux8.0.in6                            6
setp  mux8.0.in7                            7
net   mpg_x_on                        =>    mux8.0.sel0
net   mpg_y_on                        =>    mux8.0.sel1
net   mpg_z_on                        =>    mux8.0.sel2 
net   mux8_float                      <=    mux8.0.out
net   mux8_float                      =>    conv-float-s32.3.in
net   mux8_s32                        <=    conv-float-s32.3.out
net   mux8_s32                        =>    select8.0.sel
net   mpg_x                           <=    select8.0.out1
net   mpg_y                           <=    select8.0.out2
net   mpg_z                           <=    select8.0.out4
net   mpg_x                           =>    axis.x.jog-enable
net   mpg_y                           =>    axis.y.jog-enable
net   mpg_z                           =>    axis.z.jog-enable

#turn on handwheel lamps
net   mpg_x_on                        =>    hm2_7i92.0.7i77.0.0.output-08
net   mpg_y_on                        =>    hm2_7i92.0.7i77.0.0.output-09
net   mpg_z_on                        =>    hm2_7i92.0.7i77.0.0.output-10
net   mpg_on_state                    =>    hm2_7i92.0.7i77.0.0.output-11
net   mpg_jog_rate_state              =>    hm2_7i92.0.7i77.0.0.output-12 

#joint jogging using physical buttons
#jogspeed set in postgui.hal
net   mcp_jog_x_plus_S13              =>    halui.joint.0.plus    halui.axis.x.plus
net   mcp_jog_x_minus_S14             =>    halui.joint.0.minus   halui.axis.x.minus
net   mcp_jog_y_plus_S12              =>    halui.joint.1.plus    halui.axis.y.plus
net   mcp_jog_y_minus_S15             =>    halui.joint.1.minus   halui.axis.y.minus
net   mcp_jog_z_plus_S16              =>    halui.joint.2.plus    halui.axis.z.plus
net   mcp_jog_z_minus_S11             =>    halui.joint.2.minus   halui.axis.z.minus

#Select axis to jog - assumes only one joint at a time!
net   mcp_jog_x_plus_S13              =>    or2.0.in0
net   mcp_jog_x_minus_S14             =>    or2.0.in1
net   mcp_jog_joint_0                 <=    or2.0.out

net   mcp_jog_y_plus_S12              =>    or2.1.in0
net   mcp_jog_y_minus_S15             =>    or2.1.in1
net   mcp_jog_joint_1                 <=    or2.1.out             

net   mcp_jog_z_plus_S16              =>    or2.2.in0
net   mcp_jog_z_minus_S11             =>    or2.2.in1
net   mcp_jog_joint_2                 <=    or2.2.out

net   jog_joint_0                     =>    halui.joint.0.select    halui.axis.x.select
net   jog_joint_1                     =>    halui.joint.1.select    halui.axis.y.select
net   jog_joint_2                     =>    halui.joint.2.select    halui.axis.z.select

#Home-all using physical button
net   mcp_home_S10                    =>    halui.home-all

#Feed override
loadusr -W feed_override
net    mcp_feed_override_analog               =>    feed_override.mcp_analog
net    feed_override_setpoint                 <=    feed_override.setpoint
setp   halui.feed-override.direct-value             true
setp   halui.feed-override.count-enable             true
setp   halui.feed-override.scale                    0.01
net    feed_override_setpoint                 =>    halui.feed-override.counts

#Coolant
#Controlled via GUI switches on UI (qtdragon_hd) or M7 (mist ON), M8 (flood ON), M9 (mist and flood OFF)
#Turns off on E-stop.
#Operator can select both at same time.
#TODO Test if this needs to be turned off during tool change
net    mist_coolant_relay_K28       <=     halui.mist.is-on        
net    flood_coolant_relay_K29      <=     halui.flood.is-on  

#custom components
#central lubrication
# - manually triggered from machine control panel
# - automatically triggered from accumulated time in motion
loadusr -W central_lube
net	   mcp_lube_cycle_S23 			          =>    central_lube.lube_cycle_switch
net	   lube_pressure_switch_S34               =>    central_lube.pressure_switch
net    central_lube_pump_relay_K22	          =>	  central_lube.central_lube_pump_on
net    central_lube_in_motion_type            <=    motion.motion-type
net    central_lube_in_motion_type            =>    central_lube.in_motion_type
net    central_lube_cycle_count               <=    central_lube.central_lube_cycles
net    central_lube_motion_time               <=    central_lube.motion_time
setp   central_lube.min_runtime		  		        5.0  #s
setp   central_lube.max_runtime			            15.0 #s
setp   central_lube.auto_lube_rest_time	            1800 #s
setp   central_lube.man_lube_rest_time              6   #s

#spindle lubrication
# - manually triggered from machine control panel
# - automatically triggered on timer based on spindle run time
loadusr -W spindle_lube
net	   mcp_lube_cycle_S23 			          =>    spindle_lube.lube_cycle_switch
net    spindle_lube_relay_K19   	          =>  	spindle_lube.spindle_lube_pump_on
net    spindle_on                             =>    spindle_lube.spindle_on
net    spindle_lube_cycle_count               <=    spindle_lube.spindle_lube_cycles
net    spindle_lube_motion_time               <=    spindle_lube.motion_time
setp   spindle_lube.min_runtime		  		        2.0  #s
setp   spindle_lube.max_runtime			            4.0  #s
setp   spindle_lube.auto_lube_rest_time             600  #s
setp   spindle_lube.man_lube_rest_time              6    #s

#lubrication signalling to UI
net    lube_pressure_switch_S34               =>    or2.5.in0
net    spindle_lube_relay_K19                 =>    or2.5.in1
net    lube_is_on                             <=    or2.5.out
#net    lube_is_on                             =>    halui.lube.is-on

#Joint X
setp   pid.x.Pgain                                  [JOINT_0]P
setp   pid.x.Igain                                  [JOINT_0]I
setp   pid.x.Dgain                                  [JOINT_0]D
setp   pid.x.bias                                   [JOINT_0]BIAS
setp   pid.x.FF0                                    [JOINT_0]FF0
setp   pid.x.FF1                                    [JOINT_0]FF1
setp   pid.x.FF2                                    [JOINT_0]FF2
setp   pid.x.deadband                               [JOINT_0]DEADBAND
setp   pid.x.maxoutput                              [JOINT_0]MAX_OUTPUT
setp   pid.x.error-previous-target                  true

net    x-index-enable                         <=>   pid.x.index-enable
net    enable_servo_drives                    =>    pid.x.enable
net    x-pos-cmd                              =>    pid.x.command

net    x-pos-fb                               =>    pid.x.feedback
net    x-output                                     pid.x.output

# PWM Generator signals/setup---
setp   hm2_7i92.0.7i77.0.1.analogout0-scalemax      [JOINT_0]OUTPUT_SCALE_MAX
setp   hm2_7i92.0.7i77.0.1.analogout0-minlim        [JOINT_0]OUTPUT_MIN_LIMIT
setp   hm2_7i92.0.7i77.0.1.analogout0-maxlim        [JOINT_0]OUTPUT_MAX_LIMIT

net     x-output                              =>    hm2_7i92.0.7i77.0.1.analogout0
net     x-pos-cmd                             =>    joint.0.motor-pos-cmd
#net     x_axis_servo_drive_ok                 =>    joint.0.amp-enable-out
#net     x_axis_servo_drive_ok                 =>    joint.0.amp-fault_in.not

# encoder feedback signals/setup
setp    hm2_7i92.0.encoder.00.counter-mode          0
setp    hm2_7i92.0.encoder.00.filter                1
setp    hm2_7i92.0.encoder.00.index-invert          0
setp    hm2_7i92.0.encoder.00.index-mask            0
setp    hm2_7i92.0.encoder.00.index-mask-invert     0
setp    hm2_7i92.0.encoder.00.scale                 [JOINT_0]ENCODER_SCALE

net     x-pos-fb                              <=    hm2_7i92.0.encoder.00.position
net     x-vel-fb                              <=    hm2_7i92.0.encoder.00.velocity

setp    lowpass.0.gain                              0.1
net     x-vel-fb                              =>    lowpass.0.in
net     x-vel-fb_filtered                     <=    lowpass.0.out

net     x-pos-fb                              =>    joint.0.motor-pos-fb
net     x-index-enable   joint.0.index-enable <=>   hm2_7i92.0.encoder.00.index-enable
net     x-pos-rawcounts                       <=    hm2_7i92.0.encoder.00.rawcounts

# setup home / limit switch signals---
net     x_plus_reduce                         =>    joint.0.home-sw-in
net     x_minus_range_end                     =>    joint.0.neg-lim-sw-in
net     x_plus_range_end                      =>    joint.0.pos-lim-sw-in

#Joint Y
setp   pid.y.Pgain                                  [JOINT_1]P
setp   pid.y.Igain                                  [JOINT_1]I
setp   pid.y.Dgain                                  [JOINT_1]D
setp   pid.y.bias                                   [JOINT_1]BIAS
setp   pid.y.FF0                                    [JOINT_1]FF0
setp   pid.y.FF1                                    [JOINT_1]FF1
setp   pid.y.FF2                                    [JOINT_1]FF2
setp   pid.y.deadband                               [JOINT_1]DEADBAND
setp   pid.y.maxoutput                              [JOINT_1]MAX_OUTPUT
setp   pid.y.error-previous-target                  true

net    y-index-enable                         <=>   pid.y.index-enable
net    enable_servo_drives                    =>    pid.y.enable
net    y-pos-cmd                              =>    pid.y.command

net    y-pos-fb                               =>    pid.y.feedback
net    y-output                                     pid.y.output

# PWM Generator signals/setup---
setp   hm2_7i92.0.7i77.0.1.analogout1-scalemax      [JOINT_1]OUTPUT_SCALE_MAX
setp   hm2_7i92.0.7i77.0.1.analogout1-minlim        [JOINT_1]OUTPUT_MIN_LIMIT
setp   hm2_7i92.0.7i77.0.1.analogout1-maxlim        [JOINT_1]OUTPUT_MAX_LIMIT

net     y-output                              =>    hm2_7i92.0.7i77.0.1.analogout1
net     y-pos-cmd                             =>    joint.1.motor-pos-cmd
#net     y_axis_servo_drive_ok                 =>    joint.1.amp-enable-out
#net     y_axis_servo_drive_fault              =>    joint.1.amp-fault-in.not

# encoder feedback signals/setup
setp    hm2_7i92.0.encoder.01.counter-mode          0
setp    hm2_7i92.0.encoder.01.filter                1
setp    hm2_7i92.0.encoder.01.index-invert          0
setp    hm2_7i92.0.encoder.01.index-mask            0
setp    hm2_7i92.0.encoder.01.index-mask-invert     0
setp    hm2_7i92.0.encoder.01.scale                 [JOINT_1]ENCODER_SCALE

net     y-pos-fb                              <=    hm2_7i92.0.encoder.01.position
net     y-vel-fb                              <=    hm2_7i92.0.encoder.01.velocity

setp    lowpass.1.gain                              0.1
net     y-vel-fb                              =>    lowpass.1.in
net     y-vel-fb_filtered                     <=    lowpass.1.out

net     y-pos-fb                              =>    joint.1.motor-pos-fb
net     y-index-enable   joint.1.index-enable <=>   hm2_7i92.0.encoder.01.index-enable
net     y-pos-rawcounts                       <=    hm2_7i92.0.encoder.01.rawcounts

# setup home / limit switch signals---
net     y_plus_reduce                         =>    joint.1.home-sw-in
net     y_minus_range_end                     =>    joint.1.neg-lim-sw-in
net     y_plus_range_end                      =>    joint.1.pos-lim-sw-in


#Joint Z
setp   pid.z.Pgain                                  [JOINT_2]P
setp   pid.z.Igain                                  [JOINT_2]I
setp   pid.z.Dgain                                  [JOINT_2]D
setp   pid.z.bias                                   [JOINT_2]BIAS
setp   pid.z.FF0                                    [JOINT_2]FF0
setp   pid.z.FF1                                    [JOINT_2]FF1
setp   pid.z.FF2                                    [JOINT_2]FF2
setp   pid.z.deadband                               [JOINT_2]DEADBAND
setp   pid.z.maxoutput                              [JOINT_2]MAX_OUTPUT
setp   pid.z.error-previous-target                  true

net    z-index-enable                         <=>   pid.z.index-enable
net    enable_servo_drives                    =>    pid.z.enable
net    z-pos-cmd                              =>    pid.z.command

net    z-pos-fb                               =>    pid.z.feedback
net    z-output                                     pid.z.output

# PWM Generator signals/setup---
setp   hm2_7i92.0.7i77.0.1.analogout2-scalemax      [JOINT_2]OUTPUT_SCALE_MAX
setp   hm2_7i92.0.7i77.0.1.analogout2-minlim        [JOINT_2]OUTPUT_MIN_LIMIT
setp   hm2_7i92.0.7i77.0.1.analogout2-maxlim        [JOINT_2]OUTPUT_MAX_LIMIT

net     z-output                              =>    hm2_7i92.0.7i77.0.1.analogout2
net     z-pos-cmd                             =>    joint.2.motor-pos-cmd
#net     z_axis_servo_drive_ok                 =>    joint.2.amp-enable-out
#net     z_axis_servo_drive_fault              =>    joint.2.amp-fault-in.not

# encoder feedback signals/setup
setp    hm2_7i92.0.encoder.02.counter-mode          0
setp    hm2_7i92.0.encoder.02.filter                1
setp    hm2_7i92.0.encoder.02.index-invert          0
setp    hm2_7i92.0.encoder.02.index-mask            0
setp    hm2_7i92.0.encoder.02.index-mask-invert     0
setp    hm2_7i92.0.encoder.02.scale                 [JOINT_2]ENCODER_SCALE

net     z-pos-fb                              <=    hm2_7i92.0.encoder.02.position
net     z-vel-fb                              <=    hm2_7i92.0.encoder.02.velocity

setp    lowpass.2.gain                              0.1
net     z-vel-fb                              =>    lowpass.2.in
net     z-vel-fb_filtered                     <=    lowpass.2.out

net     z-pos-fb                              =>    joint.2.motor-pos-fb
net     z-index-enable   joint.2.index-enable <=>   hm2_7i92.0.encoder.02.index-enable
net     z-pos-rawcounts                       <=    hm2_7i92.0.encoder.02.rawcounts

# setup home / limit switch signals---
net     z_plus_reduce                         =>    joint.2.home-sw-in
net     z_minus_range_end                     =>    joint.2.neg-lim-sw-in
net     z_plus_range_end                      =>    joint.2.pos-lim-sw-in

#loadusr -W mqtt-publisher --mqtt-broker=[MQTT]BROKER \
#--mqtt-user=[MQTT]USERNAME --mqtt-password=[MQTT]PASSWORD \
#keys=iocontrol.0.emc-enable-in,\
#halui.machine.is-on,\
#halui.mode.is-auto,\
#halui.mode.is-manual,\
#halui.mode.is-mdi,\
#spindle.0.speed-in,\
#spindle.0.at-speed,\
#spindle.0.override.value,\
#motion.feed-mm-per-minute,\
#motion.feed-inhibit,\
#halui.feed-override.value

#loadusr -W mqtt_user_comp
#net   gear_ratio                              =>    mqtt_user_comp.gear_ratio
#net   state_machine_state                     =>    mqtt_user_comp.state_machine_state
#net   gearbox_hirange_state                   =>    mqtt_user_comp.gearbox_hirange_state
#net   central_lube_pump_relay_K22 	          =>	  mqtt_user_comp.central_lube_pump_on
#net   central_lube_cycle_count                =>    mqtt_user_comp.central_lube_cycles
#net   spindle_lube_relay_K19   	              =>	  mqtt_user_comp.spindle_lube_pump_on
#net   spindle_lube_cycle_count                =>    mqtt_user_comp.spindle_lube_cycles

#servo open loop tuning
#loadusr -W servo_open_loop_tuning
#setp   servo_open_loop_tuning.target_velocity_mm_s  60
#setp   servo_open_loop_tuning.acceleration_mm_s2    300
#setp   servo_open_loop_tuning.travel_distance_mm    130
#setp   servo_open_loop_tuning.num_cycles            1
#setp   servo_open_loop_tuning.loop_period_s         0.001
#net    enable_servo_drives              <=   hm2_7i92.0.7i77.0.0.input-31
#net    enable_servo_drives              =>   hm2_7i92.0.7i77.0.0.output-07 
#net    cycle_run                  =>       servo_open_loop_tuning.cycle_start
#net    y_axis_servo_drive_ok      =>       servo_open_loop_tuning.drive_health_status
#net    y-output                   <=       servo_open_loop_tuning.velocity_signal
#net    y_axis_brake_relay_K11     <=       servo_open_loop_tuning.brake_release_relay
#net    integrated_position        <=       servo_open_loop_tuning.integrated_position 


